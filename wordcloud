<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tagcloud</title>
    <style>
        html, body{
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
    <style>
        #word-cloud{
            height: 115vh;
            width: 200vh;
            margin: 1% auto;
            font-size: 250%;
        }
    </style>
    <style>
        a {
            text-decoration: none;
        }
    </style>
</head>
<body>
<div id="word-cloud"></div>
<script>
    let config = {
        trace: true,
        spiralResolution: 1, //Lower = better resolution
        spiralLimit: 500 * 5,
        lineHeight: 0.8,
        xWordPadding: 4,
        yWordPadding: 3,
        font: "Aileron"
    };


    let cloud = document.getElementById("word-cloud");
    cloud.style.position = "relative";
    cloud.style.fontFamily = config.font;

    colors = ['#103c5a',
        '#80697c',
        '#908a96',
        '#a2570a',
        '#291a0b'];

    let startPoint = {
        x: cloud.offsetWidth / 2,
        y: cloud.offsetHeight / 2
    };

    let wordsDown = [];

    function shuffle(a){
        let j;
        let temp;
        for(let i = a.length - 1; i > 0; i--){
            j = Math.floor(Math.random()*(i + 1));
            temp = a[j];
            a[j] = a[i];
            a[i] = temp;
        }
        return a;
    }

    function titleCase(word){
        if (word.includes('-')){
            let temp = word.toLowerCase().split('-');
            for (let i = 0;i < temp.length; i++){
                temp[i] = temp[i][0].toUpperCase() + temp[i].slice(1);
            }
            return (temp.join('-'));
        }
        else{
            let temp = word.toLowerCase().split(' ');
            for (let i = 0;i < temp.length; i++){
                temp[i] = temp[i][0].toUpperCase() + temp[i].slice(1);
            }
            return (temp.join(' '));
        }
    }

    function createWordObject(word) {
        let wordContainer = document.createElement("div");
        wordContainer.style.position = "absolute";
        wordContainer.style.lineHeight = config.lineHeight;
        //wordContainer.style.color = colors[Math.floor(Math.random() * colors.length)];
        wordContainer.style.transform = "translateY(-50%)";
        w = document.createTextNode(word);
        let a = document.createElement('a');
        a.href = "https://onomedia.today/dev?type=search&value=";
        let titleWord = titleCase(word);
        a.href += titleWord;
        a.appendChild(w);
        wordContainer.appendChild(a);
        return wordContainer;
    }

    function placeWord(word, x, y) {

        cloud.appendChild(word);
        word.style.left = x - word.offsetWidth/2 + "px";
        word.style.top = y - word.offsetHeight/2 + "px";

        wordsDown.push(word.getBoundingClientRect());
    }


    function spiral(i, callback) {
        return callback ? callback() : null;
    }

    function intersect(word, x, y) {
        cloud.appendChild(word);

        word.style.left = x - word.offsetWidth/2 + "px";
        word.style.top = y - word.offsetHeight/2 + "px";

        let currentWord = word.getBoundingClientRect();

        cloud.removeChild(word);

        for(var i = 0; i < wordsDown.length; i+=1){
            var comparisonWord = wordsDown[i];

            if(!(currentWord.right + config.xWordPadding < comparisonWord.left - config.xWordPadding ||
                currentWord.left - config.xWordPadding > comparisonWord.right + config.xWordPadding ||
                currentWord.bottom + config.yWordPadding < comparisonWord.top - config.yWordPadding ||
                currentWord.top - config.yWordPadding > comparisonWord.bottom + config.yWordPadding)){

                return true;
            }
        }

        return false;
    }


    let people = [];
    let places = [];
    let things = [];
    let whatUrl = "https://api.onomedia.today/api/trends/what";
    let whoUrl = "https://api.onomedia.today/api/trends/who";
    let whereUrl = "https://api.onomedia.today/api/trends/where";

    let firstRequest = new XMLHttpRequest();
    firstRequest.open('GET', whereUrl);
    firstRequest.responseType = 'json';
    firstRequest.send();
    firstRequest.onload = function(){
        let where = firstRequest.response;
        for (let i = 0; i <= 5; i++){
            places.push(where[`${i}`])
        }
    };

    let secondRequest = new XMLHttpRequest();
    secondRequest.open('GET', whatUrl);
    secondRequest.responseType = 'json';
    secondRequest.send();
    secondRequest.onload = function(){
        let what = secondRequest.response;
        for (let i = 0; i <= 5; i++){
            things.push(what[`${i}`])
        }
        let request = new XMLHttpRequest();
        request.open('GET', whoUrl);
        request.responseType = 'json';
        request.send();
        request.onload = function() {
            let who = request.response;
            for (let i = 0; i <= 5; i++) {
                people.push(who[`${i}`])
            }
            let words = [];
            words.push(...people,...places,...things);
            shuffle(words);
            (function placeWords() {
                for (let i = 0; i < words.length; i ++) {

                    let word = createWordObject(words[i]);
                    word.style.color = colors[i];

                    for (let j = 0; j < config.spiralLimit; j++) {
                        //If the spiral function returns true, we've placed the word down and can break from the j loop
                        if (spiral(j, function () {
                            let angle = config.spiralResolution * j;
                            let x = (1 + angle) * 2 *Math.sin(angle);
                            if (Math.random() < 0.5){
                                x -= Math.floor(Math.random() * 75);
                            }
                            else {
                                x += Math.floor(Math.random() * 75);
                            }
                            let y = (1 + angle) *1.2* Math.cos(angle);
                            if (!intersect(word, startPoint.x + x, startPoint.y + y)) {
                                placeWord(word, startPoint.x + x, startPoint.y + y);
                                return true;
                            }
                        })) {
                            break;
                        }
                    }
                }

            })();
            (function colorLinks() {
                let links = document.getElementsByTagName('a');
                for (let i = 0; i < links.length; i++) {
                    links[i].style.color = colors[Math.floor(Math.random() * colors.length)];
                }
            })();
        };

        (function colorLinks() {
            let links = document.getElementsByTagName('a');
            for (let i = 0; i < links.length; i++) {
                links[i].style.color = colors[Math.floor(Math.random() * colors.length)];
            }
        })();
    }
</script>
</body>
</html>
